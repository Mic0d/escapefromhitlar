<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Google Passwords</title>
  <style>
    :root { --game-width: 400px; --game-height: 600px; }

    html,body {
      height: 100%;
      margin: 0;
      background: #222;
      font-family: Arial, Helvetica, sans-serif;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #gameArea {
      position: relative;
      width: var(--game-width);
      height: var(--game-height);
      background: linear-gradient(180deg,#4b4b4b,#3a3a3a);
      border-radius: 10px;
      border: 4px solid #333;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    }

    /* Single balance label */
    #scoreboard {
      position: absolute;
      top: 10px;
      left: 10px;
      background: #fff;
      color: #000;
      padding: 8px 14px;
      border-radius: 10px;
      font-weight: 800;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      z-index: 80;
      min-width: 160px;
      text-align: left;
    }

    /* Center warning / death overlay */
    #warning {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: rgba(200,20,20,0.95);
      color: #fff;
      padding: 18px 22px;
      border-radius: 10px;
      font-size: 18px;
      font-weight: 700;
      text-align: center;
      display: none;
      z-index: 200;
      white-space: pre-line;
    }
    #warning button {
      margin-top: 12px;
      padding: 8px 14px;
      border-radius: 6px;
      border: none;
      background: #fff;
      color: #c00;
      font-weight: 700;
      cursor: pointer;
    }

    /* Player slightly higher */
    #player {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 50px;
      background-image: url('https://www.pngkey.com/png/detail/327-3272410_jews-laughing-meme-png-jews-laughing-meme-evil.png');
      background-size: cover;
      background-position: center;
      z-index: 60;
      pointer-events: none;
    }

    .coin {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(circle at 30% 30%, #fff7b2, gold 40%, #c79a00 100%);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(255,215,0,0.8);
      z-index: 30;
    }

    .enemy {
      position: absolute;
      width: 60px;
      height: 60px;
      background-image: url('https://c0.uidownload.com/pngpics/1125/180/adolf-hitler-silhouette-nazi-party-leader-illustration-monochrome-political-figure-black-and-white-historical-stencil-military-uniform-profile-world-war-ii-era-art-german-dictator.png');
      background-size: cover;
      background-position: center;
      border-radius: 8px;
      z-index: 40;
    }

    /* Big enemy as static image (no GIF) */
    .bigEnemyImg {
      position: absolute;
      width: 140px;
      height: 140px;
      background-image: url('https://media1.tenor.com/m/ex-J35EhIBcAAAAd/alex-jones-jew-alexjonesjew.gif');
      background-size: cover;
      background-position: center;
      border-radius: 12px;
      z-index: 70;
      pointer-events: none;
    }

    .multiplierCoin {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: linear-gradient(135deg,#8a2be2,#ff69b4);
      box-shadow: 0 0 18px rgba(200,0,200,0.9);
      border: 2px solid #fff;
      z-index: 50;
    }

    .x5Coin {
      position: absolute;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff9d6, #ffd700 40%, #b88600 100%);
      box-shadow: 0 0 24px rgba(255,215,0,0.95);
      border: 2px solid #fff;
      z-index: 75;
    }

    /* small helper styles */
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="gameArea" aria-label="Game area">
    <div id="scoreboard">ðŸ’° Total: $0.00</div>
    <div id="warning" role="dialog" aria-hidden="true"></div>
    <div id="player" aria-hidden="true"></div>
  </div>

  <script>
    /************************************************************************
     * Single-balance version
     * - No cashout system
     * - One label (#scoreboard) shows the total balance
     * - Big enemy is a static image (big-enemy.png) â€” no GIFs
     * - Speed/spawn scaling capped at $120
     * - On death overlay shows how much was collected
     ************************************************************************/

    // Game state
    let total = 0;           // single total balance for the run
    let gameOver = false;

    // DOM
    const gameArea = document.getElementById('gameArea');
    const scoreboard = document.getElementById('scoreboard');
    const warning = document.getElementById('warning');
    const playerEl = document.getElementById('player');

    // Movement
    let playerX = (gameArea.offsetWidth - 50) / 2;
    let targetX = playerX;
    let useMouseControl = false;
    let warningTimeout = null;

    // Cap scaling at $120 so game doesn't get faster past that
    function effectiveForScaling() {
      return Math.min(total, 120);
    }

    function updateUI() {
      scoreboard.textContent = `ðŸ’° Total: $${total.toFixed(2)}`;
    }

    function showWarning(message, withButton = false, persistent = false) {
      if (warningTimeout) { clearTimeout(warningTimeout); warningTimeout = null; }
      warning.innerHTML = message + (withButton ? `<br><button id="warningRestartBtn">Restart</button>` : '');
      warning.style.display = 'block';
      warning.setAttribute('aria-hidden', 'false');

      if (withButton) {
        setTimeout(() => {
          const btn = document.getElementById('warningRestartBtn');
          if (btn) btn.addEventListener('click', restartGame);
        }, 0);
      }

      if (!withButton && !persistent && !gameOver) {
        warningTimeout = setTimeout(() => {
          warning.style.display = 'none';
          warning.setAttribute('aria-hidden', 'true');
          warningTimeout = null;
        }, 1500);
      }
    }

    function restartGame() {
      location.reload();
    }

    // Smooth player movement
    function updatePlayerPosition() {
      if (gameOver) return;
      playerX += (targetX - playerX) * 0.18;
      playerX = Math.max(0, Math.min(gameArea.offsetWidth - 50, playerX));
      playerEl.style.left = playerX + 'px';
      requestAnimationFrame(updatePlayerPosition);
    }
    updatePlayerPosition();

    // Controls
    document.addEventListener('keydown', (ev) => {
      if (gameOver) return;
      const key = ev.key.toLowerCase();
      if (key === 'm') {
        useMouseControl = !useMouseControl;
        showWarning(useMouseControl ? 'ðŸ–± Mouse control enabled' : 'âŒ¨ï¸ Keyboard control enabled');
        return;
      }
      if (!useMouseControl) {
        if (key === 'a') targetX -= 36;
        if (key === 'd') targetX += 36;
        targetX = Math.max(0, Math.min(gameArea.offsetWidth - 50, targetX));
      }
    });

    document.addEventListener('mousemove', (ev) => {
      if (gameOver || !useMouseControl) return;
      const rect = gameArea.getBoundingClientRect();
      const mouseX = ev.clientX - rect.left;
      targetX = Math.max(0, Math.min(gameArea.offsetWidth - 50, mouseX - 25));
    });

    // Spawn scaling (capped)
    function getSpawnIntervalMs() {
      const base = 700;
      const effective = effectiveForScaling();
      const reduction = Math.min(effective / 400, 0.7);
      return Math.max(120, base * (1 - reduction));
    }

    function getEnemyChance() {
      let chance = 0.4 + (effectiveForScaling() / 400);
      if (chance > 0.95) chance = 0.95;
      return chance;
    }

    // Spawn loop
    function spawnLoop() {
      if (gameOver) return;
      spawnObject();
      setTimeout(spawnLoop, getSpawnIntervalMs());
    }

    function decideSpawnX(isEnemy, width = 60) {
      if (isEnemy && Math.random() < 0.4) {
        const jitter = (Math.random() * 60) - 30;
        return Math.max(0, Math.min(gameArea.offsetWidth - width, playerX + jitter));
      }
      return Math.random() * (gameArea.offsetWidth - width);
    }

    // Spawning objects (coins, enemies, multiplier, big enemy + x5)
    function spawnObject() {
      if (gameOver) return;

      // Chance to spawn big enemy (rare)
      const bigEnemyChance = 0.03 + Math.min(effectiveForScaling() / 5000, 0.07);
      if (Math.random() < bigEnemyChance) {
        const spawnX = decideSpawnX(true, 140);

        // big enemy as static image element (no GIF)
        const big = document.createElement('div');
        big.className = 'bigEnemyImg';
        big.style.left = spawnX + 'px';
        big.style.top = '-160px';
        gameArea.appendChild(big);

        // x5 coin directly in front of big enemy
        const x5 = document.createElement('div');
        x5.className = 'x5Coin';
        const x5Left = spawnX + (140 - 48) / 2;
        x5.style.left = x5Left + 'px';
        x5.style.top = '-220px';
        gameArea.appendChild(x5);

        startFall(x5, 'x5');
        startFall(big, 'bigEnemy');
        return;
      }

      // Normal spawn path
      const enemyChance = getEnemyChance();
      const isEnemy = Math.random() < enemyChance;
      const spawnX = decideSpawnX(isEnemy, isEnemy ? 60 : 30);

      const el = document.createElement('div');
      el.style.left = spawnX + 'px';
      el.style.top = '0px';

      if (isEnemy) {
        el.className = 'enemy';
      } else {
        el.className = 'coin';
      }

      gameArea.appendChild(el);

      // Rare multiplier coin in front of a normal enemy
      if (isEnemy && Math.random() < 0.08) {
        const m = document.createElement('div');
        m.className = 'multiplierCoin';
        m.style.left = (spawnX + 8) + 'px';
        m.style.top = '-48px';
        gameArea.appendChild(m);
        startFall(m, 'multiplier');
      }

      startFall(el, isEnemy ? 'enemy' : 'coin');
    }

    // Falling and collision logic
    function startFall(el, type = '') {
      const tickMs = 30;
      const interval = setInterval(() => {
        if (gameOver) {
          if (el.parentElement) el.remove();
          clearInterval(interval);
          return;
        }

        const currentTop = parseFloat(el.style.top) || 0;
        const effective = effectiveForScaling();
        const speed = (5 + effective / 6);
        el.style.top = (currentTop + speed) + 'px';

        const elRect = el.getBoundingClientRect();
        const playerRect = playerEl.getBoundingClientRect();

        const collided =
          elRect.bottom >= playerRect.top &&
          elRect.top <= playerRect.bottom &&
          elRect.left <= playerRect.right &&
          elRect.right >= playerRect.left;

        if (collided) {
          // COIN: add small random value
          if (type === 'coin') {
            const value = parseFloat((Math.random() * 0.9 + 0.1).toFixed(2));
            total = parseFloat((total + value).toFixed(2));
            updateUI();
          }
          // MULTIPLIER: multiply total (1.1 - 1.5)
          else if (type === 'multiplier') {
            const multiplier = parseFloat((Math.random() * 0.4 + 1.1).toFixed(2));
            total = parseFloat((total * multiplier).toFixed(2));
            showWarning(`âœ¨ Multiplied by x${multiplier.toFixed(2)}`);
            updateUI();
          }
          // NORMAL ENEMY
          else if (type === 'enemy') {
            if (total < 4) {
              const collectedAtDeath = total;
              showWarning(`âš ï¸ You Hit Lar\nCollected: $${collectedAtDeath.toFixed(2)}`, true, true);
              gameOver = true;
            } else {
              total = parseFloat((total * 0.7).toFixed(2));
              showWarning('âŒ Enemy hit! Total reduced to 70%');
              updateUI();
            }
          }
          // BIG ENEMY: removes all collected (round) and kills you
          else if (type === 'bigEnemy') {
            const collectedAtDeath = total;
            total = 0;
            updateUI();
            showWarning(`âš ï¸ You Hit Lar\nCollected: $${collectedAtDeath.toFixed(2)}`, true, true);
            gameOver = true;
          }
          // X5 coin: multiply total by 5
          else if (type === 'x5') {
            total = parseFloat((total * 5).toFixed(2));
            showWarning('ðŸ’¥ x5 Collected!');
            updateUI();
          }

          if (el.parentElement) el.remove();
          clearInterval(interval);
          return;
        }

        // remove if off-screen
        if (currentTop > gameArea.offsetHeight + 200) {
          if (el.parentElement) el.remove();
          clearInterval(interval);
          return;
        }
      }, tickMs);
    }

    // Start
    updateUI();
    spawnLoop();

    // expose restart for overlay button
    window.restartGame = restartGame;
  </script>
</body>
</html>
